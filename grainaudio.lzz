#hdr
#include <jack/jack.h>
#include <atomic>
#include <vector>
#end

#src
#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <sstream>

#define CHK(stmt) if(!(stmt)) {puts("ERROR: "#stmt); exit(1);}

using namespace std;

#end

struct audio_region {
  int start, end;
};

// TODO clean up (maybe add another T)
template <class T>
struct atomic_assign {
  std::atomic<T*> next;
  T a, b;
  T* last;

  atomic_assign() : next(0), last(&a) {}

  void write(const T& t) {
    T* val = next.exchange(0);
    if (val == last) {
      *last = t;
      next.exchange(last);
    } else {
      last = last == &a ? &b : &a;
      *last = t;
      next.exchange(last);
    }
  }

  T* read() {
    return next.exchange(0);
  }
};

struct grainaudio {
  std::vector<jack_port_t*> output_ports;
  atomic_assign<audio_region> cur_region;
  audio_region reg;
  float** audio;

  int cur_sample;
  int cur_dir;

  grainaudio(float** audio, int channels) : audio(audio), cur_sample(-1), cur_dir(1) {
    reg.start = -1;
    reg.end = -1;

    jack_client_t* client;
    CHK(client=jack_client_open("grainaudio", JackNullOption, 0));
    jack_set_process_callback(client, ::process, this);
    jack_on_shutdown(client, jack_shutdown, 0);
    for (int i=0; i<channels; i++) {
      ostringstream port_name;
      port_name << "out " << i;
      output_ports.push_back(jack_port_register(client,
                                                port_name.str().c_str(),
                                                JACK_DEFAULT_AUDIO_TYPE,
                                                JackPortIsOutput | JackPortIsTerminal,
                                                0));
    }

    CHK(!jack_activate(client));
  }

  void set_region(int start, int end) {
    //printf("setting region %d %d\n", start, end);
    audio_region new_region {start,end};
    cur_region.write(new_region);
  }

  void process(jack_nframes_t nframes) {
    audio_region* next_reg = cur_region.read();
    if (next_reg) {
      reg = *next_reg;
      //printf("got new region %d %d\n", reg.start, reg.end);
    }

    if (cur_sample < reg.start || cur_sample >= reg.end) {
      // cross fade
      cur_sample = reg.start;
      cur_dir = 1;
    }

    int orig_cur_sample = cur_sample;

    for (int chan=0; chan<output_ports.size(); chan++) {
      jack_default_audio_sample_t* buffer =
        (jack_default_audio_sample_t*)
        jack_port_get_buffer(output_ports[chan], nframes);

      cur_sample = orig_cur_sample;

      for (int i=0; i<nframes; i++) {
        if (reg.start == -1) {
          buffer[i] = 0;
          continue;
        }
        buffer[i] = audio[chan][cur_sample];

        cur_sample += cur_dir;
        if (cur_sample >= reg.end) {
          cur_sample = reg.end-1;
          cur_dir = -1;
        } else if (cur_sample < reg.start) {
          cur_sample = reg.start;
          cur_dir = 1;
        }
      }
    }
  }
};

#src
int process(jack_nframes_t nframes, void *arg) {
  ((grainaudio*)arg)->process(nframes);
  return 0;
}

void jack_shutdown(void* arg) {
  exit(1);
}
#end

// int main() {
// }
